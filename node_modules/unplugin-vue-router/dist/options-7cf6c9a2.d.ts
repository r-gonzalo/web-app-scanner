import { RouteRecordRaw } from 'vue-router';

interface CustomRouteBlock extends Partial<Omit<RouteRecordRaw, 'components' | 'component' | 'children' | 'beforeEnter' | 'name'>> {
    name?: string;
}

declare const enum TreeLeafType {
    static = 0,
    param = 1
}
interface RouteRecordOverride extends Partial<Pick<RouteRecordRaw, 'meta' | 'props' | 'alias' | 'path'>> {
    name?: string;
}
declare type SubSegment = string | TreeRouteParam;
declare class _TreeLeafValueBase {
    /**
     * flag based on the type of the segment
     */
    _type: TreeLeafType;
    /**
     * segment as defined by the file structure
     */
    rawSegment: string;
    /**
     * transformed version of the segment into a vue-router path
     */
    pathSegment: string;
    /**
     * Array of sub segments. This is usually one single elements but can have more for paths like `prefix-[param]-end.vue`
     */
    subSegments: SubSegment[];
    /**
     * fullPath of the node based on parent nodes
     */
    path: string;
    /**
     * Overrides defined by each file. The map is necessary to handle named views.
     */
    private _overrides;
    includeLoaderGuard: boolean;
    /**
     * Component path that maps to a view name, which is used for vue-router's named view feature.
     * Use `default` key for the default view.
     */
    filePaths: Map<string, string>;
    constructor(rawSegment: string, parent: TreeLeafValue | undefined, pathSegment?: string, subSegments?: SubSegment[]);
    toString(): string;
    isParam(): this is TreeLeafValueParam;
    isStatic(): this is TreeLeafValueStatic;
    get overrides(): RouteRecordOverride;
    setOverride(path: string, routeBlock: CustomRouteBlock | undefined): void;
}
declare class TreeLeafValueStatic extends _TreeLeafValueBase {
    _type: TreeLeafType.static;
    constructor(rawSegment: string, parent: TreeLeafValue | undefined, pathSegment?: string);
}
interface TreeRouteParam {
    paramName: string;
    modifier: string;
    optional: boolean;
    repeatable: boolean;
    isSplat: boolean;
}
declare class TreeLeafValueParam extends _TreeLeafValueBase {
    params: TreeRouteParam[];
    _type: TreeLeafType.param;
    constructor(rawSegment: string, parent: TreeLeafValue | undefined, params: TreeRouteParam[], pathSegment: string, subSegments: SubSegment[]);
}
declare type TreeLeafValue = TreeLeafValueStatic | TreeLeafValueParam;

declare class TreeLeaf {
    /**
     * value of the node
     */
    value: TreeLeafValue;
    /**
     * children of the node
     */
    children: Map<string, TreeLeaf>;
    /**
     * Parent node.
     */
    parent?: TreeLeaf;
    /**
     * Plugin options taken into account by the tree.
     */
    options: ResolvedOptions;
    constructor(options: ResolvedOptions, filePath: string, parent?: TreeLeaf);
    /**
     * Adds a path to the tree. `path` cannot start with a `/`.
     *
     * @param path - route path of the file
     * @param filePath - file path, defaults to path for convenience and testing
     */
    insert(path: string, filePath?: string): TreeLeaf;
    setCustomRouteBlock(path: string, routeBlock: CustomRouteBlock | undefined): void;
    getSortedChildren(): TreeLeaf[];
    remove(path: string): void;
    get path(): string;
    get fullPath(): string;
    get name(): string;
    get meta(): string;
    get params(): TreeRouteParam[];
    isRoot(): boolean;
    toString(): string;
}
declare function createPrefixTree(options: ResolvedOptions): TreeLeaf;

interface RoutesFolderOption {
    src: string;
    path?: string;
}
declare type _RoutesFolder = string | RoutesFolderOption;
declare type RoutesFolder = _RoutesFolder[] | _RoutesFolder;
interface ResolvedOptions {
    /**
     * Extensions of files to be considered as pages. Defaults to `['.vue']`. Cannot be empty.
     */
    extensions: string[];
    /**
     * Folder containing the components that should be used for routes. Can also be an array if you want to add multiple
     * folders, or an object if you want to define a route prefix. Supports glob patterns but must be a folder, use
     * `extensions` and `exclude` to filter files.
     *
     * @default "src/pages"
     */
    routesFolder: RoutesFolder;
    /**
     * Method to generate the name of a route.
     */
    getRouteName: (node: TreeLeaf) => string;
    /**
     * EXPERIMENTAL: add the data fetching meta properties to generated routes.
     */
    dataFetching: boolean;
    /**
     * Array of file globs to ignore. Defaults to `[]`.
     */
    exclude: string[];
    /**
     * Root of the project. All paths are resolved relatively to this one. Defaults to `process.cwd()`.
     */
    root: string;
    /**
     * Language for `<route>` blocks in SFC files. Defaults to `'json5'`.
     */
    routeBlockLang: string;
    /**
     * Should generate d.ts files. Defaults to `true` if `typescript` is installed.
     */
    dts: boolean | string;
    /**
     * Allows inspection by vite-plugin-inspect by not adding the leading `\0` to the id of virtual modules.
     * @internal
     */
    _inspect: boolean;
    /**
     * Activates debug logs.
     */
    logs: boolean;
}
declare type Options = Partial<ResolvedOptions>;
declare const DEFAULT_OPTIONS: ResolvedOptions;
interface ServerContext {
    invalidate: (module: string) => void;
    reload: () => void;
}
declare function normalizeRoutesFolderOption(routesFolder: ResolvedOptions['routesFolder']): RoutesFolderOption[];

export { DEFAULT_OPTIONS as D, Options as O, ResolvedOptions as R, ServerContext as S, TreeLeaf as T, _RoutesFolder as _, RoutesFolderOption as a, RoutesFolder as b, createPrefixTree as c, normalizeRoutesFolderOption as n };
