"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtime.ts
var runtime_exports = {};
__export(runtime_exports, {
  _LoaderSymbol: () => LoaderSymbol,
  _defineLoader: () => defineLoader,
  _setupDataFetchingGuard: () => setupDataFetchingGuard,
  _stopScope: () => stopScope
});
module.exports = __toCommonJS(runtime_exports);

// src/data-fetching/defineLoader.ts
var import_vue_router = require("vue-router");

// src/data-fetching/dataCache.ts
var import_vue = require("vue");
function isCacheExpired(entry, options) {
  const { cacheTime } = options;
  return !cacheTime || Date.now() - entry.when >= cacheTime || Array.from(entry.loaders).some(
    (childEntry) => isCacheExpired(childEntry, options)
  );
}
function createDataCacheEntry(options) {
  return withinScope(() => ({
    pending: (0, import_vue.ref)(false),
    error: (0, import_vue.ref)(),
    when: Date.now(),
    loaders: /* @__PURE__ */ new Set(),
    data: (0, import_vue.ref)(),
    params: {},
    query: {},
    isReady: false
  }));
}
function updateDataCacheEntry(entry, data, params, query, hash) {
  entry.when = Date.now();
  entry.params = params;
  entry.query = query;
  entry.hash = hash.v;
  entry.isReady = true;
  entry.data.value = data;
}
var scope;
function withinScope(fn) {
  return (scope = scope || (0, import_vue.effectScope)(true)).run(fn);
}
function stopScope() {
  if (scope) {
    scope.stop();
    scope = void 0;
  }
}
var currentContext;
function getCurrentContext() {
  return currentContext || [];
}
function setCurrentContext(context) {
  currentContext = context;
}

// src/data-fetching/defineLoader.ts
var DEFAULT_DEFINE_LOADER_OPTIONS = {
  cacheTime: 1e3 * 5,
  lazy: false
};
function defineLoader(nameOrLoader, _loaderOrOptions, opts) {
  const loader = typeof nameOrLoader === "function" ? nameOrLoader : _loaderOrOptions;
  opts = typeof _loaderOrOptions === "object" ? _loaderOrOptions : opts;
  const options = { ...DEFAULT_DEFINE_LOADER_OPTIONS, ...opts };
  const dataLoader = () => {
    let [parentEntry, _router, _route] = getCurrentContext();
    const router = _router || (0, import_vue_router.useRouter)();
    const route = _route || (0, import_vue_router.useRoute)();
    if (!cache.has(router) || parentEntry) {
      load(route, router, parentEntry);
    }
    const entry = cache.get(router);
    const promise = Promise.resolve(pendingPromise).then(() => dataLoaderResult).finally(() => {
      if (parentEntry) {
        parentEntry.loaders.add(entry);
      }
      setCurrentContext(parentEntry && [parentEntry, router, route]);
    });
    const { data, pending, error } = entry;
    function refresh() {
      invalidate();
      load(route, router, parentEntry);
      return pendingPromise.catch(() => {
      });
    }
    function invalidate() {
      entry.when = 0;
    }
    const dataLoaderResult = {
      data,
      pending,
      error,
      refresh,
      invalidate,
      pendingLoad
    };
    return Object.assign(promise, dataLoaderResult);
  };
  const cache = /* @__PURE__ */ new WeakMap();
  let pendingPromise;
  let currentNavigation;
  const pendingLoad = () => pendingPromise;
  function load(route, router, parent) {
    const hasCacheEntry = cache.has(router);
    const needsNewLoad = !hasCacheEntry || shouldFetchAgain(cache.get(router), route);
    if (!hasCacheEntry) {
      cache.set(router, createDataCacheEntry(options));
    }
    const entry = cache.get(router);
    const { isReady, pending, error } = entry;
    const { lazy } = options;
    const isExpired = isCacheExpired(entry, options);
    if (pendingPromise && !needsNewLoad && currentNavigation === route && (!isReady || !isExpired)) {
      return lazy ? Promise.resolve() : pendingPromise;
    }
    if (needsNewLoad || !isReady && currentNavigation !== route || isReady && isExpired) {
      pending.value = true;
      error.value = null;
      currentNavigation = route;
      const [trackedRoute, params, query, hash] = trackRoute(route);
      if (!pendingPromise) {
        setCurrentContext([entry, router, route]);
      }
      const thisPromise = pendingPromise = loader(trackedRoute).then((data) => {
        if (pendingPromise === thisPromise) {
          updateDataCacheEntry(entry, data, params, query, hash);
        }
      }).catch((err) => {
        error.value = err;
        return Promise.reject(err);
      }).finally(() => {
        if (pendingPromise === thisPromise) {
          pendingPromise = null;
          pending.value = false;
        }
        setCurrentContext(parent && [parent, router, route]);
      });
    }
    return lazy || !pendingPromise ? Promise.resolve() : pendingPromise;
  }
  dataLoader._ = {
    loader,
    cache,
    load
  };
  dataLoader[IsLoader] = true;
  return dataLoader;
}
function shouldFetchAgain(entry, route) {
  return !entry.when || !includesParams(route.params, entry.params) || !includesParams(route.query, entry.query) || entry.hash != null && entry.hash !== route.hash || Array.from(entry.loaders).some(
    (childEntry) => shouldFetchAgain(childEntry, route)
  );
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else if (!innerValue || !outerValue) {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
var IsLoader = Symbol();
function isDataLoader(loader) {
  return loader && loader[IsLoader];
}
function trackRoute(route) {
  const [params, paramReads] = trackObjectReads(route.params);
  const [query, queryReads] = trackObjectReads(route.query);
  let hash = { v: null };
  return [
    {
      ...route,
      get hash() {
        return hash.v = route.hash;
      },
      params,
      query
    },
    paramReads,
    queryReads,
    hash
  ];
}
function trackObjectReads(obj) {
  const reads = {};
  return [
    new Proxy(obj, {
      get(target, p, receiver) {
        const value = Reflect.get(target, p, receiver);
        reads[p] = value;
        return value;
      }
    }),
    reads
  ];
}

// src/data-fetching/dataFetchingGuard.ts
var LoaderSymbol = Symbol();
var added = false;
function setupDataFetchingGuard(router) {
  if (added) {
    console.warn(
      "[vue-router]: Data fetching guard added twice. Make sure to remove the extra call."
    );
    return;
  }
  added = true;
  return router.beforeEach((to) => {
    return Promise.all(
      to.matched.flatMap((route) => route.meta[LoaderSymbol]).filter((moduleImport) => moduleImport).map(
        (moduleImport) => moduleImport().then((mod) => {
          const loaders = Object.keys(mod).filter((exportName) => isDataLoader(mod[exportName])).map((loaderName) => mod[loaderName]);
          return Promise.all(
            loaders.map((loader) => {
              return loader._.load(to, router);
            })
          );
        })
      )
    ).then(() => true);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _LoaderSymbol,
  _defineLoader,
  _setupDataFetchingGuard,
  _stopScope
});
