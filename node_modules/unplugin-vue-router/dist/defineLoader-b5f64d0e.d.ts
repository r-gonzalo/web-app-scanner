import { RouteParams, LocationQuery, RouteRecordName, RouteLocationNormalizedLoaded, Router } from 'vue-router';
import { Ref, UnwrapRef } from 'vue';

interface DataLoaderCacheEntry<T = unknown, isLazy = boolean> {
    /**
     * When was the data loaded in ms (Date.now()).
     * @internal
     */
    when: number;
    params: Partial<RouteParams>;
    query: Partial<LocationQuery>;
    hash: string | null;
    loaders: Set<DataLoaderCacheEntry>;
    /**
     * Whether there is an ongoing request.
     */
    pending: Ref<boolean>;
    /**
     * Error if there was an error.
     */
    error: Ref<any>;
    isReady: boolean;
    /**
     * Data stored in the cache.
     */
    data: false extends isLazy ? Ref<UnwrapRef<T>> : Ref<UnwrapRef<T> | undefined>;
}
/**
 * Stop and invalidate the scope used for data. Note this will make any application stop working. It should be used only
 * if there is a need to manually stop a running application without stopping the process.
 */
declare function stopScope(): void;

interface DefineLoaderOptions<isLazy extends boolean = boolean> {
    /**
     * How long should we wait to consider the fetched data expired. Amount in ms. Defaults to 5 minutes. A value of 0
     * means no cache while a value of `Infinity` means cache forever.
     */
    cacheTime?: number;
    /**
     * Whether the data should be lazy loaded without blocking the navigation or not. Defaults to false. When set to true
     * or a function, the loader will no longer block the navigation and the returned composable can be called even
     * without having the data ready. This also means that the data will be available as one single `ref()` named `data`
     * instead of all the individual properties returned by the loader.
     */
    lazy?: isLazy;
}
/**
 * Loader function that can be passed to `defineLoader()`.
 */
interface DefineLoaderFn<T> {
    (route: RouteLocationNormalizedLoaded): T extends Promise<any> ? T : Promise<T>;
}
declare function defineLoader<P extends Promise<any>, isLazy extends boolean = false>(name: RouteRecordName, loader: DefineLoaderFn<P>, options?: DefineLoaderOptions<isLazy>): DataLoader<Awaited<P>, isLazy>;
declare function defineLoader<P extends Promise<any>, isLazy extends boolean = false>(loader: DefineLoaderFn<P>, options?: DefineLoaderOptions<isLazy>): DataLoader<Awaited<P>, isLazy>;
declare const IsLoader: unique symbol;
declare type _PromiseMerged<T> = T & Promise<T>;
interface DataLoader<T, isLazy extends boolean = boolean> {
    (): _PromiseMerged<_DataLoaderResult<T, isLazy>>;
    [IsLoader]: true;
    /**
     * Internal context for the loader.
     * @internal
     */
    _: _DataLoaderInternals<T>;
}
/**
 * Holds internal state of a loader.
 *
 * @internal
 */
interface _DataLoaderInternals<T> {
    loader: (route: RouteLocationNormalizedLoaded) => Promise<T>;
    /**
     * Loads the data from the cache if possible, otherwise loads it from the loader and awaits it.
     */
    load: (route: RouteLocationNormalizedLoaded, router: Router) => Promise<void>;
    /**
     * The data loaded by the loader associated with the router instance. As one router instance can only be used for one
     * app, it ensures the cache is not shared among requests.
     */
    cache: WeakMap<Router, DataLoaderCacheEntry<T>>;
}
interface _DataLoaderResult<T = unknown, isLazy = boolean> {
    /**
     * Whether there is an ongoing request.
     */
    pending: Ref<boolean>;
    /**
     * Error if there was an error.
     */
    error: Ref<any>;
    /**
     * Refresh the data. Returns a promise that resolves when the data is refreshed.
     */
    refresh: () => Promise<void>;
    /**
     * Invalidates the data so it is reloaded on the next request.
     */
    invalidate: () => void;
    /**
     * Get the promise of the current loader if there is one, returns a falsy value otherwise.
     */
    pendingLoad: () => Promise<void> | undefined | null;
    /**
     * Data returned by the loader.
     */
    data: false extends isLazy ? Ref<UnwrapRef<T>> : Ref<UnwrapRef<T> | undefined>;
}

export { DefineLoaderOptions as D, DataLoader as a, defineLoader as d, stopScope as s };
