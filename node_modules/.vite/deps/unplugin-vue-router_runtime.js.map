{
  "version": 3,
  "sources": ["../../unplugin-vue-router/dist/runtime.mjs"],
  "sourcesContent": ["// src/data-fetching/defineLoader.ts\nimport {\n  useRouter,\n  useRoute\n} from \"vue-router\";\n\n// src/data-fetching/dataCache.ts\nimport { ref, effectScope } from \"vue\";\nfunction isCacheExpired(entry, options) {\n  const { cacheTime } = options;\n  return !cacheTime || Date.now() - entry.when >= cacheTime || Array.from(entry.loaders).some(\n    (childEntry) => isCacheExpired(childEntry, options)\n  );\n}\nfunction createDataCacheEntry(options) {\n  return withinScope(() => ({\n    pending: ref(false),\n    error: ref(),\n    when: Date.now(),\n    loaders: /* @__PURE__ */ new Set(),\n    data: ref(),\n    params: {},\n    query: {},\n    isReady: false\n  }));\n}\nfunction updateDataCacheEntry(entry, data, params, query, hash) {\n  entry.when = Date.now();\n  entry.params = params;\n  entry.query = query;\n  entry.hash = hash.v;\n  entry.isReady = true;\n  entry.data.value = data;\n}\nvar scope;\nfunction withinScope(fn) {\n  return (scope = scope || effectScope(true)).run(fn);\n}\nfunction stopScope() {\n  if (scope) {\n    scope.stop();\n    scope = void 0;\n  }\n}\nvar currentContext;\nfunction getCurrentContext() {\n  return currentContext || [];\n}\nfunction setCurrentContext(context) {\n  currentContext = context;\n}\n\n// src/data-fetching/defineLoader.ts\nvar DEFAULT_DEFINE_LOADER_OPTIONS = {\n  cacheTime: 1e3 * 5,\n  lazy: false\n};\nfunction defineLoader(nameOrLoader, _loaderOrOptions, opts) {\n  const loader = typeof nameOrLoader === \"function\" ? nameOrLoader : _loaderOrOptions;\n  opts = typeof _loaderOrOptions === \"object\" ? _loaderOrOptions : opts;\n  const options = { ...DEFAULT_DEFINE_LOADER_OPTIONS, ...opts };\n  const dataLoader = () => {\n    let [parentEntry, _router, _route] = getCurrentContext();\n    const router = _router || useRouter();\n    const route = _route || useRoute();\n    if (!cache.has(router) || parentEntry) {\n      load(route, router, parentEntry);\n    }\n    const entry = cache.get(router);\n    const promise = Promise.resolve(pendingPromise).then(() => dataLoaderResult).finally(() => {\n      if (parentEntry) {\n        parentEntry.loaders.add(entry);\n      }\n      setCurrentContext(parentEntry && [parentEntry, router, route]);\n    });\n    const { data, pending, error } = entry;\n    function refresh() {\n      invalidate();\n      load(route, router, parentEntry);\n      return pendingPromise.catch(() => {\n      });\n    }\n    function invalidate() {\n      entry.when = 0;\n    }\n    const dataLoaderResult = {\n      data,\n      pending,\n      error,\n      refresh,\n      invalidate,\n      pendingLoad\n    };\n    return Object.assign(promise, dataLoaderResult);\n  };\n  const cache = /* @__PURE__ */ new WeakMap();\n  let pendingPromise;\n  let currentNavigation;\n  const pendingLoad = () => pendingPromise;\n  function load(route, router, parent) {\n    const hasCacheEntry = cache.has(router);\n    const needsNewLoad = !hasCacheEntry || shouldFetchAgain(cache.get(router), route);\n    if (!hasCacheEntry) {\n      cache.set(router, createDataCacheEntry(options));\n    }\n    const entry = cache.get(router);\n    const { isReady, pending, error } = entry;\n    const { lazy } = options;\n    const isExpired = isCacheExpired(entry, options);\n    if (pendingPromise && !needsNewLoad && currentNavigation === route && (!isReady || !isExpired)) {\n      return lazy ? Promise.resolve() : pendingPromise;\n    }\n    if (needsNewLoad || !isReady && currentNavigation !== route || isReady && isExpired) {\n      pending.value = true;\n      error.value = null;\n      currentNavigation = route;\n      const [trackedRoute, params, query, hash] = trackRoute(route);\n      if (!pendingPromise) {\n        setCurrentContext([entry, router, route]);\n      }\n      const thisPromise = pendingPromise = loader(trackedRoute).then((data) => {\n        if (pendingPromise === thisPromise) {\n          updateDataCacheEntry(entry, data, params, query, hash);\n        }\n      }).catch((err) => {\n        error.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        if (pendingPromise === thisPromise) {\n          pendingPromise = null;\n          pending.value = false;\n        }\n        setCurrentContext(parent && [parent, router, route]);\n      });\n    }\n    return lazy || !pendingPromise ? Promise.resolve() : pendingPromise;\n  }\n  dataLoader._ = {\n    loader,\n    cache,\n    load\n  };\n  dataLoader[IsLoader] = true;\n  return dataLoader;\n}\nfunction shouldFetchAgain(entry, route) {\n  return !entry.when || !includesParams(route.params, entry.params) || !includesParams(route.query, entry.query) || entry.hash != null && entry.hash !== route.hash || Array.from(entry.loaders).some(\n    (childEntry) => shouldFetchAgain(childEntry, route)\n  );\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue)\n        return false;\n    } else if (!innerValue || !outerValue) {\n      if (innerValue !== outerValue)\n        return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))\n        return false;\n    }\n  }\n  return true;\n}\nvar IsLoader = Symbol();\nfunction isDataLoader(loader) {\n  return loader && loader[IsLoader];\n}\nfunction trackRoute(route) {\n  const [params, paramReads] = trackObjectReads(route.params);\n  const [query, queryReads] = trackObjectReads(route.query);\n  let hash = { v: null };\n  return [\n    {\n      ...route,\n      get hash() {\n        return hash.v = route.hash;\n      },\n      params,\n      query\n    },\n    paramReads,\n    queryReads,\n    hash\n  ];\n}\nfunction trackObjectReads(obj) {\n  const reads = {};\n  return [\n    new Proxy(obj, {\n      get(target, p, receiver) {\n        const value = Reflect.get(target, p, receiver);\n        reads[p] = value;\n        return value;\n      }\n    }),\n    reads\n  ];\n}\n\n// src/data-fetching/dataFetchingGuard.ts\nvar LoaderSymbol = Symbol();\nvar added = false;\nfunction setupDataFetchingGuard(router) {\n  if (added) {\n    console.warn(\n      \"[vue-router]: Data fetching guard added twice. Make sure to remove the extra call.\"\n    );\n    return;\n  }\n  added = true;\n  return router.beforeEach((to) => {\n    return Promise.all(\n      to.matched.flatMap((route) => route.meta[LoaderSymbol]).filter((moduleImport) => moduleImport).map(\n        (moduleImport) => moduleImport().then((mod) => {\n          const loaders = Object.keys(mod).filter((exportName) => isDataLoader(mod[exportName])).map((loaderName) => mod[loaderName]);\n          return Promise.all(\n            loaders.map((loader) => {\n              return loader._.load(to, router);\n            })\n          );\n        })\n      )\n    ).then(() => true);\n  });\n}\nexport {\n  LoaderSymbol as _LoaderSymbol,\n  defineLoader as _defineLoader,\n  setupDataFetchingGuard as _setupDataFetchingGuard,\n  stopScope as _stopScope\n};\n"],
  "mappings": "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",
  "names": []
}
